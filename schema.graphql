schema {
  query: RootQueryType
  mutation: RootMutationType
}

input CreateRepresentativeInput {
  name: String
}

"""The result of the :create_representative mutation"""
type CreateRepresentativeResult {
  """Any errors generated, if the mutation failed"""
  errors: [MutationError]

  """The successful result of the mutation"""
  result: Representative
}

input CreateTicketInput {
  representativeId: ID
  status: TicketStatus
  subject: String!
}

"""The result of the :create_ticket mutation"""
type CreateTicketResult {
  """Any errors generated, if the mutation failed"""
  errors: [MutationError]

  """The successful result of the mutation"""
  result: Ticket
}

"""
The `DateTime` scalar type represents a date and time in the UTC
timezone. The DateTime appears in a JSON response as an ISO8601 formatted
string, including UTC timezone ("Z"). The parsed date and time string will
be converted to UTC if there is an offset.
"""
scalar DateTime

"""The result of the :destroy_representative mutation"""
type DestroyRepresentativeResult {
  """Any errors generated, if the mutation failed"""
  errors: [MutationError]

  """The record that was successfully deleted"""
  result: Representative
}

"""The result of the :destroy_ticket mutation"""
type DestroyTicketResult {
  """Any errors generated, if the mutation failed"""
  errors: [MutationError]

  """The record that was successfully deleted"""
  result: Ticket
}

"""
The `Json` scalar type represents arbitrary json string data, represented as UTF-8
character sequences. The Json type is most often used to represent a free-form
human-readable json string.
"""
scalar Json

"""An error generated by a failed mutation"""
type MutationError {
  """An error code for the given error"""
  code: String

  """The field or fields that produced the error"""
  fields: [String]

  """The human readable error message"""
  message: String

  """A shorter error message, with vars not replaced"""
  shortMessage: String

  """Replacements for the short message"""
  vars: Json
}

"""A relay node"""
interface Node {
  """A unique identifier"""
  id: ID!
}

"""A relay page info"""
type PageInfo {
  """When paginating forwards, the cursor to continue"""
  endCursor: String

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue"""
  startCursor: String
}

type Representative implements Node {
  closedTickets: Int!
  id: ID!
  insertedAt: DateTime!
  name: String
  openTickets: Int!
  percentOpen: Float
  tickets(
    """Show records after the specified keyset."""
    after: String

    """Show records before the specified keyset."""
    before: String

    """A filter to limit the results"""
    filter: TicketFilterInput

    """The number of records to return from the beginning. Maximum 250"""
    first: Int

    """The number of records to return to the end. Maximum 250"""
    last: Int

    """The number of records to return."""
    limit: Int

    """The number of records to skip."""
    offset: Int

    """How to sort the records in the response"""
    sort: [TicketSortInput]
  ): [Ticket!]!
  totalTickets: Int!
  updatedAt: DateTime!
}

""":representative connection"""
type RepresentativeConnection {
  """Total count on all pages"""
  count: Int

  """:representative edges"""
  edges: [RepresentativeEdge]

  """Page information"""
  pageInfo: PageInfo!
}

""":representative edge"""
type RepresentativeEdge {
  """Cursor"""
  cursor: String!

  """:representative node"""
  node: Representative
}

input RepresentativeFilterClosedTickets {
  eq: Int
  greaterThan: Int
  greaterThanOrEqual: Int
  in: [Int]
  isNil: Boolean
  lessThan: Int
  lessThanOrEqual: Int
  notEq: Int
}

input RepresentativeFilterId {
  eq: ID
  greaterThan: ID
  greaterThanOrEqual: ID
  in: [ID!]
  isNil: Boolean
  lessThan: ID
  lessThanOrEqual: ID
  notEq: ID
}

input RepresentativeFilterInput {
  and: [RepresentativeFilterInput!]
  closedTickets: RepresentativeFilterClosedTickets
  id: RepresentativeFilterId
  insertedAt: RepresentativeFilterInsertedAt
  name: RepresentativeFilterName
  openTickets: RepresentativeFilterOpenTickets
  or: [RepresentativeFilterInput!]
  percentOpen: RepresentativeFilterPercentOpen
  tickets: TicketFilterInput
  totalTickets: RepresentativeFilterTotalTickets
  updatedAt: RepresentativeFilterUpdatedAt
}

input RepresentativeFilterInsertedAt {
  eq: DateTime
  greaterThan: DateTime
  greaterThanOrEqual: DateTime
  in: [DateTime!]
  isNil: Boolean
  lessThan: DateTime
  lessThanOrEqual: DateTime
  notEq: DateTime
}

input RepresentativeFilterName {
  eq: String
  greaterThan: String
  greaterThanOrEqual: String
  in: [String]
  isNil: Boolean
  lessThan: String
  lessThanOrEqual: String
  notEq: String
}

input RepresentativeFilterOpenTickets {
  eq: Int
  greaterThan: Int
  greaterThanOrEqual: Int
  in: [Int]
  isNil: Boolean
  lessThan: Int
  lessThanOrEqual: Int
  notEq: Int
}

input RepresentativeFilterPercentOpen {
  eq: Float
  greaterThan: Float
  greaterThanOrEqual: Float
  in: [Float!]
  isNil: Boolean
  lessThan: Float
  lessThanOrEqual: Float
  notEq: Float
}

input RepresentativeFilterTotalTickets {
  eq: Int
  greaterThan: Int
  greaterThanOrEqual: Int
  in: [Int]
  isNil: Boolean
  lessThan: Int
  lessThanOrEqual: Int
  notEq: Int
}

input RepresentativeFilterUpdatedAt {
  eq: DateTime
  greaterThan: DateTime
  greaterThanOrEqual: DateTime
  in: [DateTime!]
  isNil: Boolean
  lessThan: DateTime
  lessThanOrEqual: DateTime
  notEq: DateTime
}

enum RepresentativeSortField {
  CLOSED_TICKETS
  ID
  INSERTED_AT
  NAME
  OPEN_TICKETS
  PERCENT_OPEN
  TOTAL_TICKETS
  UPDATED_AT
}

input RepresentativeSortInput {
  field: RepresentativeSortField!
  order: SortOrder = ASC
}

type RootMutationType {
  createRepresentative(input: CreateRepresentativeInput): CreateRepresentativeResult
  createTicket(input: CreateTicketInput): CreateTicketResult
  destroyRepresentative(id: ID): DestroyRepresentativeResult
  destroyTicket(id: ID): DestroyTicketResult
  updateRepresentative(id: ID, input: UpdateRepresentativeInput): UpdateRepresentativeResult
  updateTicket(id: ID, input: UpdateTicketInput): UpdateTicketResult
}

type RootQueryType {
  getRepresentative(
    """The id of the record"""
    id: ID!
  ): Representative
  getTicket(
    """The id of the record"""
    id: ID!
  ): Ticket
  listRepresentatives(
    """Show records after the specified keyset."""
    after: String

    """Show records before the specified keyset."""
    before: String

    """A filter to limit the results"""
    filter: RepresentativeFilterInput

    """The number of records to return from the beginning. Maximum 250"""
    first: Int

    """The number of records to return to the end. Maximum 250"""
    last: Int

    """How to sort the records in the response"""
    sort: [RepresentativeSortInput]
  ): RepresentativeConnection
  listTickets(
    """Show records after the specified keyset."""
    after: String

    """Show records before the specified keyset."""
    before: String

    """A filter to limit the results"""
    filter: TicketFilterInput

    """The number of records to return from the beginning. Maximum 250"""
    first: Int

    """The number of records to return to the end. Maximum 250"""
    last: Int

    """How to sort the records in the response"""
    sort: [TicketSortInput]
  ): TicketConnection
}

enum SortOrder {
  ASC
  DESC
}

type Ticket implements Node {
  id: ID!
  insertedAt: DateTime!
  representative: Representative
  representativeId: ID
  status: TicketStatus!
  subject: String!
  updatedAt: DateTime!
}

""":ticket connection"""
type TicketConnection {
  """Total count on all pages"""
  count: Int

  """:ticket edges"""
  edges: [TicketEdge]

  """Page information"""
  pageInfo: PageInfo!
}

""":ticket edge"""
type TicketEdge {
  """Cursor"""
  cursor: String!

  """:ticket node"""
  node: Ticket
}

input TicketFilterId {
  eq: ID
  greaterThan: ID
  greaterThanOrEqual: ID
  in: [ID!]
  isNil: Boolean
  lessThan: ID
  lessThanOrEqual: ID
  notEq: ID
}

input TicketFilterInput {
  and: [TicketFilterInput!]
  id: TicketFilterId
  insertedAt: TicketFilterInsertedAt
  or: [TicketFilterInput!]
  representative: RepresentativeFilterInput
  representativeId: TicketFilterRepresentativeId
  status: TicketFilterStatus
  subject: TicketFilterSubject
  updatedAt: TicketFilterUpdatedAt
}

input TicketFilterInsertedAt {
  eq: DateTime
  greaterThan: DateTime
  greaterThanOrEqual: DateTime
  in: [DateTime!]
  isNil: Boolean
  lessThan: DateTime
  lessThanOrEqual: DateTime
  notEq: DateTime
}

input TicketFilterRepresentativeId {
  eq: ID
  greaterThan: ID
  greaterThanOrEqual: ID
  in: [ID]
  isNil: Boolean
  lessThan: ID
  lessThanOrEqual: ID
  notEq: ID
}

input TicketFilterStatus {
  eq: TicketStatus
  greaterThan: TicketStatus
  greaterThanOrEqual: TicketStatus
  in: [TicketStatus!]
  isNil: Boolean
  lessThan: TicketStatus
  lessThanOrEqual: TicketStatus
  notEq: TicketStatus
}

input TicketFilterSubject {
  eq: String
  greaterThan: String
  greaterThanOrEqual: String
  in: [String!]
  isNil: Boolean
  lessThan: String
  lessThanOrEqual: String
  notEq: String
}

input TicketFilterUpdatedAt {
  eq: DateTime
  greaterThan: DateTime
  greaterThanOrEqual: DateTime
  in: [DateTime!]
  isNil: Boolean
  lessThan: DateTime
  lessThanOrEqual: DateTime
  notEq: DateTime
}

enum TicketSortField {
  ID
  INSERTED_AT
  REPRESENTATIVE_ID
  STATUS
  SUBJECT
  UPDATED_AT
}

input TicketSortInput {
  field: TicketSortField!
  order: SortOrder = ASC
}

enum TicketStatus {
  CLOSED
  OPEN
}

input UpdateRepresentativeInput {
  name: String
}

"""The result of the :update_representative mutation"""
type UpdateRepresentativeResult {
  """Any errors generated, if the mutation failed"""
  errors: [MutationError]

  """The successful result of the mutation"""
  result: Representative
}

input UpdateTicketInput {
  representativeId: ID
  status: TicketStatus
  subject: String
}

"""The result of the :update_ticket mutation"""
type UpdateTicketResult {
  """Any errors generated, if the mutation failed"""
  errors: [MutationError]

  """The successful result of the mutation"""
  result: Ticket
}
